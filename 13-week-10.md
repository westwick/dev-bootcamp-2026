# Week 10 â€” Modern Frontend Patterns

*Month 3: The Modern Web*

---

## Goals

- Learn client-side routing with React Router
- Master form handling in React
- Understand state management patterns
- Handle loading, error, and empty states properly
- Build a polished user experience

---

## Part 1: React Router

### What to Learn

- What is client-side routing?
- How is it different from server-side routing?
- How to set up React Router
- How to navigate programmatically

### Installation

```bash
npm install react-router-dom
```

### Basic Setup

```jsx
// main.jsx
import { BrowserRouter } from 'react-router-dom';
import App from './App';

ReactDOM.createRoot(document.getElementById('root')).render(
  <BrowserRouter>
    <App />
  </BrowserRouter>
);
```

```jsx
// App.jsx
import { Routes, Route } from 'react-router-dom';
import HomePage from './pages/HomePage';
import LoginPage from './pages/LoginPage';
import ProjectsPage from './pages/ProjectsPage';
import ProjectDetailPage from './pages/ProjectDetailPage';

function App() {
  return (
    <Routes>
      <Route path="/" element={<HomePage />} />
      <Route path="/login" element={<LoginPage />} />
      <Route path="/projects" element={<ProjectsPage />} />
      <Route path="/projects/:id" element={<ProjectDetailPage />} />
    </Routes>
  );
}
```

### Navigation

```jsx
import { Link, useNavigate } from 'react-router-dom';

function Header() {
  const navigate = useNavigate();
  
  const handleLogout = () => {
    // Clear token...
    navigate('/login');
  };
  
  return (
    <nav>
      {/* Link component for navigation */}
      <Link to="/">Home</Link>
      <Link to="/projects">Projects</Link>
      
      {/* Programmatic navigation */}
      <button onClick={handleLogout}>Logout</button>
    </nav>
  );
}
```

### URL Parameters

```jsx
import { useParams } from 'react-router-dom';

function ProjectDetailPage() {
  const { id } = useParams();
  
  useEffect(() => {
    // Fetch project with this id
    fetchProject(id);
  }, [id]);
  
  return <div>Project {id}</div>;
}
```

### ðŸ¤– AI Learning Prompts

- "What is client-side routing and why use it?"
- "How do I set up React Router?"
- "How do I get URL parameters in React Router?"
- "What's the difference between Link and useNavigate?"

---

## Part 2: Protected Routes

### What to Learn

- How to restrict routes to logged-in users
- How to redirect unauthorized users
- How to persist login state

### Protected Route Component

```jsx
// components/ProtectedRoute.jsx
import { Navigate } from 'react-router-dom';

function ProtectedRoute({ children }) {
  const token = localStorage.getItem('token');
  
  if (!token) {
    return <Navigate to="/login" replace />;
  }
  
  return children;
}

export default ProtectedRoute;
```

### Using Protected Routes

```jsx
// App.jsx
import ProtectedRoute from './components/ProtectedRoute';

function App() {
  return (
    <Routes>
      <Route path="/login" element={<LoginPage />} />
      <Route path="/register" element={<RegisterPage />} />
      
      {/* Protected routes */}
      <Route
        path="/projects"
        element={
          <ProtectedRoute>
            <ProjectsPage />
          </ProtectedRoute>
        }
      />
      <Route
        path="/projects/:id"
        element={
          <ProtectedRoute>
            <ProjectDetailPage />
          </ProtectedRoute>
        }
      />
    </Routes>
  );
}
```

### ðŸ¤– AI Learning Prompts

- "How do I create protected routes in React?"
- "How do I redirect after successful login?"
- "Where should I store the auth token in React?"

---

## Part 3: Forms in React

### What to Learn

- Controlled vs uncontrolled components
- Handling multiple inputs
- Form validation
- Handling submission

### Controlled Components

```jsx
import { useState } from 'react';

function LoginForm() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  
  const handleSubmit = (e) => {
    e.preventDefault();
    // Submit form...
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder="Email"
      />
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="Password"
      />
      <button type="submit">Login</button>
    </form>
  );
}
```

### Managing Multiple Fields

```jsx
function LoginForm() {
  const [formData, setFormData] = useState({
    email: '',
    password: ''
  });
  
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        name="email"
        type="email"
        value={formData.email}
        onChange={handleChange}
      />
      <input
        name="password"
        type="password"
        value={formData.password}
        onChange={handleChange}
      />
      <button type="submit">Login</button>
    </form>
  );
}
```

### Form with Validation

```jsx
function LoginForm({ onLogin }) {
  const [formData, setFormData] = useState({ email: '', password: '' });
  const [errors, setErrors] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const validate = () => {
    const newErrors = {};
    if (!formData.email) {
      newErrors.email = 'Email is required';
    }
    if (!formData.password) {
      newErrors.password = 'Password is required';
    }
    return newErrors;
  };
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    const newErrors = validate();
    if (Object.keys(newErrors).length > 0) {
      setErrors(newErrors);
      return;
    }
    
    setIsSubmitting(true);
    try {
      await onLogin(formData);
    } catch (err) {
      setErrors({ form: err.message });
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      {errors.form && <p className="error">{errors.form}</p>}
      
      <div>
        <input
          name="email"
          value={formData.email}
          onChange={handleChange}
        />
        {errors.email && <span className="error">{errors.email}</span>}
      </div>
      
      <div>
        <input
          name="password"
          type="password"
          value={formData.password}
          onChange={handleChange}
        />
        {errors.password && <span className="error">{errors.password}</span>}
      </div>
      
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Logging in...' : 'Login'}
      </button>
    </form>
  );
}
```

### ðŸ¤– AI Learning Prompts

- "What is a controlled component in React?"
- "How do I handle multiple form inputs in React?"
- "How do I validate forms in React?"
- "How do I show form errors in React?"

---

## Part 4: State Management Patterns

### What to Learn

- Lifting state up
- Prop drilling problem
- Context API
- When to use global state

### Lifting State Up

When siblings need to share state, lift it to their parent:

```jsx
function App() {
  const [user, setUser] = useState(null);
  
  return (
    <div>
      <Header user={user} />
      <Main user={user} setUser={setUser} />
    </div>
  );
}
```

### Context API

For deeply nested components:

```jsx
// context/AuthContext.jsx
import { createContext, useContext, useState } from 'react';

const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [token, setToken] = useState(localStorage.getItem('token'));
  
  const login = (userData, authToken) => {
    setUser(userData);
    setToken(authToken);
    localStorage.setItem('token', authToken);
  };
  
  const logout = () => {
    setUser(null);
    setToken(null);
    localStorage.removeItem('token');
  };
  
  return (
    <AuthContext.Provider value={{ user, token, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  return useContext(AuthContext);
}
```

### Using Context

```jsx
// main.jsx
import { AuthProvider } from './context/AuthContext';

ReactDOM.createRoot(document.getElementById('root')).render(
  <BrowserRouter>
    <AuthProvider>
      <App />
    </AuthProvider>
  </BrowserRouter>
);

// Any component can now use:
import { useAuth } from './context/AuthContext';

function Header() {
  const { user, logout } = useAuth();
  
  return (
    <nav>
      {user ? (
        <>
          <span>Hello, {user.email}</span>
          <button onClick={logout}>Logout</button>
        </>
      ) : (
        <Link to="/login">Login</Link>
      )}
    </nav>
  );
}
```

### ðŸ¤– AI Learning Prompts

- "What is lifting state up in React?"
- "What is prop drilling and why is it a problem?"
- "How do I use React Context API?"
- "When should I use Context vs props?"

---

## Part 5: Loading, Error, and Empty States

### What to Learn

- Why UX states matter
- How to implement each state
- Consistent patterns across the app

### The Three States

```jsx
function ProjectList() {
  const [projects, setProjects] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    fetchProjects();
  }, []);
  
  async function fetchProjects() {
    try {
      setLoading(true);
      setError(null);
      const data = await api.getProjects();
      setProjects(data.projects);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }
  
  // Loading state
  if (loading) {
    return <Spinner />;
  }
  
  // Error state
  if (error) {
    return (
      <div className="error">
        <p>Error: {error}</p>
        <button onClick={fetchProjects}>Try Again</button>
      </div>
    );
  }
  
  // Empty state
  if (projects.length === 0) {
    return (
      <div className="empty">
        <p>No projects yet</p>
        <button onClick={() => setShowCreateForm(true)}>
          Create your first project
        </button>
      </div>
    );
  }
  
  // Success state
  return (
    <div className="project-list">
      {projects.map(project => (
        <ProjectCard key={project.id} project={project} />
      ))}
    </div>
  );
}
```

### Reusable Loading Component

```jsx
function Spinner() {
  return (
    <div className="spinner-container">
      <div className="spinner"></div>
    </div>
  );
}

// CSS
.spinner {
  border: 3px solid #f3f3f3;
  border-top: 3px solid #3498db;
  border-radius: 50%;
  width: 30px;
  height: 30px;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
```

### ðŸ¤– AI Learning Prompts

- "What are the different UI states I should handle in React?"
- "How do I show a loading spinner while fetching data?"
- "How do I handle empty states in React?"
- "What is a good pattern for handling async data in React?"

---

## âœ… Week 10 Milestone Checklist

- [ ] I can set up routing with React Router
- [ ] I can create protected routes
- [ ] I can access URL parameters
- [ ] I understand controlled components
- [ ] I can handle forms with validation
- [ ] I understand Context API
- [ ] My app handles loading, error, and empty states
- [ ] I have a polished React frontend

---

## Next Up

[Week 11: ORMs & Developer Workflow â†’](14-week-11.md)
